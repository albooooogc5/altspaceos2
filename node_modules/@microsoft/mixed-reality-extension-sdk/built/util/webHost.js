"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const Restify = __importStar(require("restify"));
const restify_errors_1 = require("restify-errors");
const etag_1 = __importDefault(require("etag"));
const __1 = require("..");
/**
 * Sets up an HTTP server, and generates an MRE context for your app to use.
 */
class WebHost {
    constructor(options = {}) {
        this.bufferMap = {};
        this.checkStaticBuffers = (req, res, next) => {
            const info = this.bufferMap[req.params.name];
            if (info) {
                res.setHeader('ETag', info.etag);
                next();
            }
            else {
                next(new restify_errors_1.NotFoundError(`No buffer registered under name ${req.params.name}`));
            }
        };
        this.serveStaticBuffers = (req, res, next) => {
            const info = this.bufferMap[req.params.name];
            if (info) {
                res.contentType = info.contentType;
                res.sendRaw(200, info.buffer);
                next();
            }
            else {
                next(new restify_errors_1.NotFoundError(`No buffer registered under name ${req.params.name}`));
            }
        };
        const pjson = require('../../package.json'); /* eslint-disable-line @typescript-eslint/no-var-requires */
        __1.log.info('app', `Node: ${process.version}`);
        __1.log.info('app', `${pjson.name}: v${pjson.version}`);
        this._baseDir = options.baseDir || process.env.BASE_DIR;
        this._baseUrl = options.baseUrl || process.env.BASE_URL;
        // Azure defines WEBSITE_HOSTNAME.
        if (!this._baseUrl && process.env.WEBSITE_HOSTNAME) {
            this._baseUrl = `https://${process.env.WEBSITE_HOSTNAME}`;
        }
        // Resolve the port number. Heroku defines a PORT environment var (remapped from 80).
        const port = options.port || process.env.PORT || 3901;
        // Create a Multi-peer adapter
        this._adapter = new __1.MultipeerAdapter({ port });
        // Start listening for new app connections from a multi-peer client.
        this._adapter.listen()
            .then(server => {
            this._baseUrl = this._baseUrl || server.url.replace(/\[::\]/u, '127.0.0.1');
            __1.log.info('app', `${server.name} listening on ${JSON.stringify(server.address())}`);
            __1.log.info('app', `baseUrl: ${this.baseUrl}`);
            __1.log.info('app', `baseDir: ${this.baseDir}`);
            if (this.baseDir) {
                this.serveStaticFiles(server);
            }
        })
            .catch(reason => __1.log.error('app', `Failed to start HTTP server: ${reason}`));
    }
    get adapter() { return this._adapter; }
    get baseDir() { return this._baseDir; }
    get baseUrl() { return this._baseUrl; }
    serveStaticFiles(server) {
        server.get(`/buffers/:name`, this.checkStaticBuffers, Restify.plugins.conditionalRequest(), this.serveStaticBuffers);
        server.get('/*', Restify.plugins.serveStaticFiles(this._baseDir));
    }
    /**
     * Serve arbitrary binary blobs from a URL
     * @param filename A unique string ID for the blob
     * @param blob A binary blob
     * @param contentType The MIME type that identifies this blob
     * @returns The URL to fetch the provided blob
     */
    registerStaticBuffer(filename, blob, contentType = 'application/octet-stream') {
        this.bufferMap[filename] = {
            buffer: blob,
            etag: etag_1.default(blob),
            contentType
        };
        return url_1.resolve(this._baseUrl, `buffers/${filename}`);
    }
}
exports.WebHost = WebHost;
//# sourceMappingURL=webHost.js.map